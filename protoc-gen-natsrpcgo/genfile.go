package main

import (
	"fmt"
	"strings"
	"unicode"

	natsrpcv1 "github.com/leetm4n/nats-proto-rpc-go/m/api/proto/nats/rpc/v1"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func generateFile(gen *protogen.Plugin, protoFile *protogen.File, isValidatorEnabled bool) {
	// if file is not generation target then skip
	if !isFileGenerationTarget(protoFile) {
		return
	}
	if countGenerationTargetServices(protoFile.Services) == 0 {
		return
	}

	filename := protoFile.GeneratedFilenamePrefix + ".pb.nrpc.go"
	generatedFile := gen.NewGeneratedFile(filename, protoFile.GoImportPath)

	addComment(generatedFile)
	addEmptyLine(generatedFile)
	addPackageName(generatedFile, protoFile)
	addEmptyLine(generatedFile)
	addImports(
		generatedFile,
		[]string{
			"context",
			"github.com/nats-io/nats.go",
			"github.com/leetm4n/nats-proto-rpc-go/m/pkg/client",
			"github.com/leetm4n/nats-proto-rpc-go/m/pkg/subject",
		},
	)
	addEmptyLine(generatedFile)
	addServices(generatedFile, protoFile.Services, isValidatorEnabled)
}

func countGenerationTargetServices(services []*protogen.Service) int {
	count := 0
	for _, service := range services {
		if isServiceGenerationTarget(service) {
			count++
		}
	}

	return count
}

func addServices(gen *protogen.GeneratedFile, services []*protogen.Service, isValidatorEnabled bool) {
	for _, service := range services {
		// if file is not generation target then skip
		if !isServiceGenerationTarget(service) {
			continue
		}

		addServiceServerInterface(gen, service)
		addEmptyLine(gen)
		addServiceClientInterface(gen, service, isValidatorEnabled)
		addEmptyLine(gen)
		addServiceClientImplementation(gen, service, isValidatorEnabled)
	}
}

func isFileGenerationTarget(file *protogen.File) bool {
	return proto.GetExtension(file.Proto.Options, natsrpcv1.E_IsFileGenerationTarget.TypeDescriptor().Type()).(bool)
}

func isServiceGenerationTarget(service *protogen.Service) bool {
	return proto.GetExtension(service.Desc.Options(), natsrpcv1.E_IsServiceGenerationTarget.TypeDescriptor().Type()).(bool)
}

func addImports(gen *protogen.GeneratedFile, imports []string) {
	gen.P("import (")
	for _, importValue := range imports {
		gen.P(fmt.Sprintf("  \"%s\"", importValue))
	}
	gen.P(")")
}

func addEmptyLine(gen *protogen.GeneratedFile) {
	gen.P()
}

func addComment(gen *protogen.GeneratedFile) {
	gen.P("// Code generated by protoc-gen-nrpc. DO NOT EDIT.")
}

func addPackageName(gen *protogen.GeneratedFile, file *protogen.File) {
	gen.P(fmt.Sprintf("package %s", file.GoPackageName))
}

func addServiceServerInterface(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("type %sNatsServer interface {", service.GoName))
	for _, method := range service.Methods {
		gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s, subjectPrefix *string) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	gen.P("}")
	addEmptyLine(gen)
}

func addServiceClientInterface(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	gen.P(fmt.Sprintf("type %sNatsClient interface {", service.GoName))
	gen.P("  client.WithEncoder")
	if isValidatorEnabled {
		gen.P("  client.WithClientValidation")
	}
	gen.P("  client.WithTimeout")
	for _, method := range service.Methods {
		gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s, subjectPrefix *string) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	gen.P("}")
}

func addServiceClientImplementation(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	addServiceClientImplStruct(gen, service)
	addServiceClientImplHandlers(gen, service, isValidatorEnabled)
	addEmptyLine(gen)
	addServiceClientImplementationConstructor(gen, service)
}

func addServiceClientImplementationConstructor(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("func New%s(natsConnection *nats.Conn) %sNatsClient {", fmt.Sprintf("%sNatsClient", service.GoName), service.GoName))
	gen.P(fmt.Sprintf("  return &%s{", fmt.Sprintf("%sNatsClient", firstLetterToLower(service.GoName))))
	gen.P("    BaseClient: *client.NewBaseClient(),")
	gen.P("    natsConnection: natsConnection,")
	gen.P("  }")
	gen.P("}")
}

func addServiceClientImplHandlers(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	for _, method := range service.Methods {
		addEmptyLine(gen)
		gen.P(fmt.Sprintf("func (c *%sNatsClient) %s(ctx context.Context, req *%s, subjectPrefix *string) (*%s, error) {", firstLetterToLower(service.GoName), method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
		gen.P(fmt.Sprintf("  subject := subject.GetSubject(\"%s\", \"%s\", subjectPrefix)", strings.ToLower(service.GoName), strings.ToLower(method.GoName)))
		if isValidatorEnabled {
			gen.P("  if (c.IsClientValidationEnabled()) {")
			gen.P("    if err := req.ValidateAll(); err != nil {")
			gen.P("      return nil, err")
			gen.P("    }")
			gen.P("  }")
		}
		gen.P("  encoded, err := c.GetEncoder().Encode(subject, req)")
		gen.P("  if err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		gen.P("  msg, err := c.natsConnection.Request(subject, encoded, c.GetTimeout())")
		gen.P("  if err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		gen.P(fmt.Sprintf("  res := new(%s)", method.Output.GoIdent.GoName))
		gen.P("  if err := c.GetEncoder().Decode(subject, msg.Data, res); err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		if isValidatorEnabled {
			gen.P("  if c.IsClientValidationEnabled() {")
			gen.P("    if err := res.ValidateAll(); err != nil {")
			gen.P("      return nil, err")
			gen.P("    }")
			gen.P("  }")
		}
		gen.P("  return res, nil")
		gen.P("}")
	}
}

func addServiceClientImplStruct(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("type %sNatsClient struct {", firstLetterToLower(service.GoName)))
	gen.P("  client.BaseClient")
	gen.P("  natsConnection *nats.Conn")
	gen.P("}")
}

func firstLetterToLower(s string) string {

	if len(s) == 0 {
		return s
	}

	r := []rune(s)
	r[0] = unicode.ToLower(r[0])

	return string(r)
}
