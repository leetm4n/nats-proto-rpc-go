package main

import (
	"fmt"
	"strings"
	"unicode"

	natsrpcv1 "github.com/leetm4n/nats-proto-rpc-go/api/proto/nats/rpc/v1"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func generateFile(gen *protogen.Plugin, protoFile *protogen.File, isValidatorEnabled bool) {
	// if file is not generation target then skip
	if !isFileGenerationTarget(protoFile) {
		return
	}
	if countGenerationTargetServices(protoFile.Services) == 0 {
		return
	}

	filename := protoFile.GeneratedFilenamePrefix + ".pb.nrpc.go"
	generatedFile := gen.NewGeneratedFile(filename, protoFile.GoImportPath)

	addComment(generatedFile, protoFile)
	addEmptyLine(generatedFile)
	addPackageName(generatedFile, protoFile)
	addEmptyLine(generatedFile)
	addImports(
		generatedFile,
		[]string{
			"context",
			"github.com/nats-io/nats.go",
			"github.com/nats-io/nats.go/micro",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/correlation",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/runnable",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/client",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/subject",
		},
	)
	addEmptyLine(generatedFile)
	addServices(generatedFile, protoFile.Services, isValidatorEnabled)
}

func countGenerationTargetServices(services []*protogen.Service) int {
	count := 0
	for _, service := range services {
		if isServiceGenerationTarget(service) {
			count++
		}
	}

	return count
}

func addServices(gen *protogen.GeneratedFile, services []*protogen.Service, isValidatorEnabled bool) {
	for _, service := range services {
		// if file is not generation target then skip
		if !isServiceGenerationTarget(service) {
			continue
		}

		addServiceServerInterface(gen, service)
		addEmptyLine(gen)
		addServiceClientInterface(gen, service, isValidatorEnabled)
		addEmptyLine(gen)
		addServiceClientImplementation(gen, service, isValidatorEnabled)
		addEmptyLine(gen)
		addServiceServerRunnableImplementation(gen, service, isValidatorEnabled)
	}
}

func isFileGenerationTarget(file *protogen.File) bool {
	return proto.GetExtension(file.Proto.Options, natsrpcv1.E_IsFileGenerationTarget.TypeDescriptor().Type()).(bool)
}

func isServiceGenerationTarget(service *protogen.Service) bool {
	return proto.GetExtension(service.Desc.Options(), natsrpcv1.E_IsServiceGenerationTarget.TypeDescriptor().Type()).(bool)
}

func addImports(gen *protogen.GeneratedFile, imports []string) {
	gen.P("import (")
	for _, importValue := range imports {
		gen.P(fmt.Sprintf("  \"%s\"", importValue))
	}
	gen.P(")")
}

func addEmptyLine(gen *protogen.GeneratedFile) {
	gen.P()
}

func addComment(gen *protogen.GeneratedFile, file *protogen.File) {
	gen.P("// Code generated by protoc-gen-nrpc. DO NOT EDIT.")
	gen.P(fmt.Sprintf("// source: %s", *file.Proto.Name))
}

func addPackageName(gen *protogen.GeneratedFile, file *protogen.File) {
	gen.P(fmt.Sprintf("package %s", file.GoPackageName))
}

func addServiceServerInterface(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("type %sNatsServer interface {", service.GoName))
	for _, method := range service.Methods {
		gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	gen.P("}")
	addEmptyLine(gen)
}

func addServiceClientInterface(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	gen.P(fmt.Sprintf("type %sNatsClient interface {", service.GoName))
	gen.P("  client.WithEncoder")
	if isValidatorEnabled {
		gen.P("  client.WithClientValidation")
	}
	gen.P("  client.WithTimeout")
	for _, method := range service.Methods {
		gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s, subjectPrefix *string) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	gen.P("}")
}

func addServiceClientImplementation(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	addServiceClientImplStruct(gen, service)
	addServiceClientImplHandlers(gen, service, isValidatorEnabled)
	addEmptyLine(gen)
	addServiceClientImplementationConstructor(gen, service)
}

func addServiceClientImplementationConstructor(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("func New%s(natsConnection *nats.Conn) %sNatsClient {", fmt.Sprintf("%sNatsClient", service.GoName), service.GoName))
	gen.P(fmt.Sprintf("  return &%s{", fmt.Sprintf("%sNatsClient", firstLetterToLower(service.GoName))))
	gen.P("    BaseClient: *client.NewBaseClient(),")
	gen.P("    natsConnection: natsConnection,")
	gen.P("  }")
	gen.P("}")
}

func addServiceClientImplHandlers(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	for _, method := range service.Methods {
		addEmptyLine(gen)
		gen.P(fmt.Sprintf("func (c *%sNatsClient) %s(ctx context.Context, req *%s, subjectPrefix *string) (*%s, error) {", firstLetterToLower(service.GoName), method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
		gen.P(fmt.Sprintf("  subject := subject.GetSubject(\"%s\", \"%s\", subjectPrefix)", strings.ToLower(service.GoName), strings.ToLower(method.GoName)))
		if isValidatorEnabled {
			gen.P("  if (c.IsClientValidationEnabled()) {")
			gen.P("    if err := req.ValidateAll(); err != nil {")
			gen.P("      return nil, err")
			gen.P("    }")
			gen.P("  }")
		}
		gen.P("  encoded, err := c.GetEncoder().Encode(subject, req)")
		gen.P("  if err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		gen.P("  correlationID := correlation.CorrelationIDFromContext(ctx)")
		gen.P("  var header nats.Header")
		gen.P("  if correlationID != \"\" {")
		gen.P("    header.Add(correlation.RequestIDHeaderKey, correlationID)")
		gen.P("  }")
		gen.P("	 msg, err := c.natsConnection.RequestMsg(&nats.Msg{ Subject: subject, Data: encoded, Header: header }, c.GetTimeout())")
		gen.P("  if err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		gen.P(fmt.Sprintf("  res := new(%s)", method.Output.GoIdent.GoName))
		gen.P("  if err := c.GetEncoder().Decode(subject, msg.Data, res); err != nil {")
		gen.P("    return nil, err")
		gen.P("  }")
		if isValidatorEnabled {
			gen.P("  if c.IsClientValidationEnabled() {")
			gen.P("    if err := res.ValidateAll(); err != nil {")
			gen.P("      return nil, err")
			gen.P("    }")
			gen.P("  }")
		}
		gen.P("  return res, nil")
		gen.P("}")
	}
}

func addServiceClientImplStruct(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("type %sNatsClient struct {", firstLetterToLower(service.GoName)))
	gen.P("  client.BaseClient")
	gen.P("  natsConnection *nats.Conn")
	gen.P("}")
}

func addServiceServerRunnableImplementation(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	addServiceServerRunnableImplStruct(gen, service)
	addServiceServerRunnableImpl(gen, service, isValidatorEnabled)
	addEmptyLine(gen)
	addServiceServerRunnableConstructor(gen, service)
}

func addServiceServerRunnableImplStruct(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("type %sNatsServerRunnable struct {", firstLetterToLower(service.GoName)))
	gen.P(fmt.Sprintf("  %sNatsServer %sNatsServer", firstLetterToLower(service.GoName), service.GoName))
	gen.P("  natsConnection *nats.Conn")
	gen.P("  service *micro.Service")
	gen.P("  options runnable.Options")
	gen.P("}")
}

func addServiceServerRunnableImpl(gen *protogen.GeneratedFile, service *protogen.Service, isValidatorEnabled bool) {
	gen.P(fmt.Sprintf("func (s *%sNatsServerRunnable) Run(ctx context.Context) error {", firstLetterToLower(service.GoName)))
	gen.P("  service, err := micro.AddService(s.natsConnection, micro.Config{")
	gen.P(fmt.Sprintf("    Name:    \"%s\",", strings.ToLower(service.GoName)))
	gen.P("	   Version: \"\",")
	gen.P("  })")
	gen.P("  if err != nil {")
	gen.P("    return err")
	gen.P("  }")
	for _, method := range service.Methods {
		gen.P(fmt.Sprintf("  %sSubject := subject.GetSubject(\"%s\", \"%s\", s.options.SubjectPrefix)", firstLetterToLower(method.GoName), strings.ToLower(service.GoName), strings.ToLower(method.GoName)))
		gen.P("  if err := service.AddEndpoint(")
		gen.P(fmt.Sprintf("    %sSubject,", firstLetterToLower(method.GoName)))
		gen.P("    micro.ContextHandler(")
		gen.P("      ctx,")
		gen.P("      func(ctx context.Context, request micro.Request) {")
		gen.P("        select {")
		gen.P("        case <-ctx.Done():")
		gen.P("          request.Error(\"400\", \"context canceled\", nil)")
		gen.P("        default:")
		gen.P(fmt.Sprintf("          req := new(%s)", method.Input.GoIdent.GoName))
		gen.P(fmt.Sprintf("          if err := s.options.Encoder.Decode(%sSubject, request.Data(), req); err != nil {", firstLetterToLower(method.GoName)))
		gen.P("            code, description := s.options.ErrorMapper(err)")
		gen.P("            request.Error(code, description, nil)")
		gen.P("            return")
		gen.P("          }")
		if isValidatorEnabled {
			gen.P("          if s.options.IsValidationEnabled {")
			gen.P("            if err := req.ValidateAll(); err != nil {")
			gen.P("              code, description := s.options.ErrorMapper(err)")
			gen.P("              request.Error(code, description, nil)")
			gen.P("              return")
			gen.P("            }")
			gen.P("          }")
		}
		gen.P(fmt.Sprintf("          res, err := s.%sNatsServer.%s(ctx, req)", firstLetterToLower(service.GoName), method.GoName))
		gen.P("          if err != nil {")
		gen.P("            code, description := s.options.ErrorMapper(err)")
		gen.P("            request.Error(code, description, nil)")
		gen.P("            return")
		gen.P("          }")
		if isValidatorEnabled {
			gen.P("          if s.options.IsValidationEnabled {")
			gen.P("            if err := res.ValidateAll(); err != nil {")
			gen.P("              code, description := s.options.ErrorMapper(err)")
			gen.P("              request.Error(code, description, nil)")
			gen.P("              return")
			gen.P("            }")
			gen.P("          }")
		}
		gen.P(fmt.Sprintf("          payload, err := s.options.Encoder.Encode(%sSubject, res)", firstLetterToLower(method.GoName)))
		gen.P("          if err != nil {")
		gen.P("					   code, description := s.options.ErrorMapper(err)")
		gen.P("						 request.Error(code, description, nil)")
		gen.P("						 return")
		gen.P("					 }")
		gen.P("          request.Respond(payload)")
		gen.P("        }")
		gen.P("      },")
		gen.P("    ),")
		gen.P("  ); err != nil {")
		gen.P("    return err")
		gen.P("  }")
	}
	gen.P("  return nil")
	gen.P("}")
	addEmptyLine(gen)
	gen.P(fmt.Sprintf("func (s *%sNatsServerRunnable) GetNatsMicroService() *micro.Service {", firstLetterToLower(service.GoName)))
	gen.P("  return s.service")
	gen.P("}")
}

func addServiceServerRunnableConstructor(gen *protogen.GeneratedFile, service *protogen.Service) {
	gen.P(fmt.Sprintf("func New%s(", fmt.Sprintf("%sRunnable", service.GoName)))
	gen.P("  natsConnection *nats.Conn,")
	gen.P(fmt.Sprintf("  %sNatsServer %sNatsServer,", firstLetterToLower(service.GoName), service.GoName))
	gen.P("  options runnable.Options,")
	gen.P(") runnable.Runnable {")
	gen.P(fmt.Sprintf("  return &%sNatsServerRunnable{", firstLetterToLower(service.GoName)))
	gen.P(fmt.Sprintf("    %sNatsServer: %sNatsServer,", firstLetterToLower(service.GoName), firstLetterToLower(service.GoName)))
	gen.P("    natsConnection: natsConnection,")
	gen.P("    options: options,")
	gen.P("  }")
	gen.P("}")
}

func firstLetterToLower(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)
	r[0] = unicode.ToLower(r[0])

	return string(r)
}
