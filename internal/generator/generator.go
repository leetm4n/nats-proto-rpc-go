package generator

import (
	"fmt"
	"strings"
	"unicode"

	natsrpcv1 "github.com/leetm4n/nats-proto-rpc-go/api/proto/nats/rpc/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var _ Generator = (*generator)(nil)

type Generator interface {
	Generate()
}

type generator struct {
	services           []*protogen.Service
	protoFile          *protogen.File
	gen                *protogen.GeneratedFile
	isValidatorEnabled bool
}

func (g *generator) Generate() {
	// this is the outline of generated code
	g.addHeaderComment()
	g.addEmptyLine()
	g.addPackageName()
	g.addEmptyLine()
	g.addImports(
		[]string{
			"context",
			"time",
			"encoding/json",
			"github.com/alecthomas/jsonschema",
			"github.com/nats-io/nats.go",
			"github.com/nats-io/nats.go/micro",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/correlation",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/runnable",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/client",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/encoder",
			"github.com/leetm4n/nats-proto-rpc-go/pkg/subject",
		},
	)
	g.addEmptyLine()
	g.addServices()
}

func New(
	services []*protogen.Service,
	protoFile *protogen.File,
	gen *protogen.GeneratedFile,
	isValidatorEnabled bool,
) Generator {
	return &generator{
		services:           services,
		protoFile:          protoFile,
		gen:                gen,
		isValidatorEnabled: isValidatorEnabled,
	}
}

func (g *generator) addServices() {
	for _, service := range g.services {
		g.addServiceServerInterface(service)
		g.addEmptyLine()
		g.addServiceClientInterface(service)
		g.addEmptyLine()
		g.addServiceClientImplementation(service)
		g.addEmptyLine()
		g.addServiceServerRunnableImplementation(service)
	}
}

func (g *generator) getServiceVersion(service *protogen.Service) string {
	return proto.GetExtension(service.Desc.Options(), natsrpcv1.E_ServiceVersion.TypeDescriptor().Type()).(string)
}

func (g *generator) getServiceSubject(service *protogen.Service) string {
	serviceSubject := service.GoName

	serviceSubjectOverride := proto.GetExtension(service.Desc.Options(), natsrpcv1.E_ServiceSubject.TypeDescriptor().Type()).(string)

	if serviceSubjectOverride != "" {
		serviceSubject = serviceSubjectOverride
	}

	return strings.ToLower(serviceSubject)
}

func (g *generator) getMethodSubject(method *protogen.Method) string {
	methodSubject := method.GoName

	methodSubjectOverride := proto.GetExtension(method.Desc.Options(), natsrpcv1.E_MethodSubject.TypeDescriptor().Type()).(string)

	if methodSubjectOverride != "" {
		methodSubject = methodSubjectOverride
	}

	return strings.ToLower(methodSubject)
}

func (g *generator) addImports(imports []string) {
	g.gen.P("import (")
	for _, importValue := range imports {
		g.gen.P(fmt.Sprintf("  \"%s\"", importValue))
	}
	g.gen.P(")")
}

func (g *generator) addEmptyLine() {
	g.gen.P()
}

func (g *generator) addHeaderComment() {
	g.gen.P("// Code generated by protoc-gen-nrpc. DO NOT EDIT.")
	g.gen.P(fmt.Sprintf("// source: %s", *g.protoFile.Proto.Name))
}

func (g *generator) addPackageName() {
	g.gen.P(fmt.Sprintf("package %s", g.protoFile.GoPackageName))
}

func (g *generator) addServiceServerInterface(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("type %sServer interface {", service.GoName))
	for _, method := range service.Methods {
		g.gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	g.gen.P("}")
	g.addEmptyLine()
}

func (g *generator) addServiceClientInterface(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("type %sClient interface {", service.GoName))
	for _, method := range service.Methods {
		g.gen.P(fmt.Sprintf("  %s(ctx context.Context, req *%s, subjectPrefix string) (res *%s, err error)", method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
	}
	g.gen.P("}")
}

func (g *generator) addServiceClientImplementation(service *protogen.Service) {
	g.addServiceClientImplStruct(service)
	g.addServiceClientImplHandlers(service)
	g.addEmptyLine()
	g.addServiceClientImplementationConstructor(service)
}

func (g *generator) addServiceClientImplHandlers(service *protogen.Service) {
	for _, method := range service.Methods {
		g.addEmptyLine()
		g.gen.P(fmt.Sprintf("func (c *%sClient) %s(ctx context.Context, req *%s, subjectPrefix string) (*%s, error) {", firstLetterToLower(service.GoName), method.GoName, method.Input.GoIdent.GoName, method.Output.GoIdent.GoName))
		g.gen.P(fmt.Sprintf("  subject := c.getSubject(\"%s\", \"%s\", subjectPrefix)", g.getServiceSubject(service), g.getMethodSubject(method)))
		if g.isValidatorEnabled {
			g.gen.P("  if (c.isValidationEnabled) {")
			g.gen.P("    if err := req.ValidateAll(); err != nil {")
			g.gen.P("      return nil, err")
			g.gen.P("    }")
			g.gen.P("  }")
		}
		g.gen.P("  encoded, err := c.encoder.Encode(subject, req)")
		g.gen.P("  if err != nil {")
		g.gen.P("    return nil, err")
		g.gen.P("  }")
		g.gen.P("  correlationID := correlation.CorrelationIDFromContext(ctx)")
		g.gen.P("  var header nats.Header")
		g.gen.P("  if correlationID != \"\" {")
		g.gen.P("    header.Add(correlation.RequestIDHeaderKey, correlationID)")
		g.gen.P("  }")
		g.gen.P("	 msg, err := c.natsConnection.RequestMsg(&nats.Msg{ Subject: subject, Data: encoded, Header: header }, c.timeout)")
		g.gen.P("  if err != nil {")
		g.gen.P("    return nil, err")
		g.gen.P("  }")
		g.gen.P(fmt.Sprintf("  res := new(%s)", method.Output.GoIdent.GoName))
		g.gen.P("  if err := c.encoder.Decode(subject, msg.Data, res); err != nil {")
		g.gen.P("    return nil, err")
		g.gen.P("  }")
		if g.isValidatorEnabled {
			g.gen.P("  if c.isValidationEnabled {")
			g.gen.P("    if err := res.ValidateAll(); err != nil {")
			g.gen.P("      return nil, err")
			g.gen.P("    }")
			g.gen.P("  }")
		}
		g.gen.P("  return res, nil")
		g.gen.P("}")
	}
}

func (g *generator) addServiceClientImplStruct(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("type %sClient struct {", firstLetterToLower(service.GoName)))
	g.gen.P("  natsConnection *nats.Conn")
	g.gen.P("  encoder encoder.Encoder")
	g.gen.P("  isValidationEnabled bool")
	g.gen.P("  getSubject subject.GetSubjectFn")
	g.gen.P("  timeout time.Duration")
	g.gen.P("}")
}

func (g *generator) addServiceClientImplementationConstructor(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("func New%sClient(options client.Options) %sClient {", service.GoName, service.GoName))
	g.gen.P(fmt.Sprintf("  return &%s{", fmt.Sprintf("%sClient", firstLetterToLower(service.GoName))))
	g.gen.P("    natsConnection: options.NatsConnection,")
	g.gen.P("    encoder: options.Encoder,")
	g.gen.P("    isValidationEnabled: options.IsValidationEnabled,")
	g.gen.P("    getSubject: options.GetSubject,")
	g.gen.P("    timeout: options.Timeout,")
	g.gen.P("  }")
	g.gen.P("}")
}

func (g *generator) addServiceServerRunnableImplementation(service *protogen.Service) {
	g.addServiceServerRunnableImplStruct(service)
	g.addServiceServerRunnableImpl(service)
	g.addEmptyLine()
	g.addServiceServerRunnableConstructor(service)
}

func (g *generator) addServiceServerRunnableImplStruct(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("type %sServerRunnable struct {", firstLetterToLower(service.GoName)))
	g.gen.P(fmt.Sprintf("  %sServer %sServer", firstLetterToLower(service.GoName), service.GoName))
	g.gen.P("  service *micro.Service")
	g.gen.P("  natsConnection      *nats.Conn")
	g.gen.P("  encoder             encoder.Encoder")
	g.gen.P("  isValidationEnabled bool")
	g.gen.P("  errorMapper         runnable.ErrorMapper")
	g.gen.P("  errorHandler        micro.ErrHandler")
	g.gen.P("  doneHandler         micro.DoneHandler")
	g.gen.P("  subjectPrefix       string")
	g.gen.P("  getSubject          subject.GetSubjectFn")
	g.gen.P("}")
}

func (g *generator) addServiceServerRunnableImpl(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("func (s *%sServerRunnable) Run(ctx context.Context) error {", firstLetterToLower(service.GoName)))
	g.gen.P("  service, err := micro.AddService(s.natsConnection, micro.Config{")
	g.gen.P(fmt.Sprintf("    Name:    \"%s\",", g.getServiceSubject(service)))
	g.gen.P(fmt.Sprintf("	   Version: \"%s\",", g.getServiceVersion(service)))
	g.gen.P("	   ErrorHandler: s.errorHandler,")
	g.gen.P("	   DoneHandler: s.doneHandler,")
	g.gen.P("  })")
	g.gen.P("  if err != nil {")
	g.gen.P("    return err")
	g.gen.P("  }")
	for _, method := range service.Methods {
		g.gen.P(fmt.Sprintf("  %sSubject := s.getSubject(\"%s\", \"%s\", s.subjectPrefix)", firstLetterToLower(method.GoName), g.getServiceSubject(service), g.getMethodSubject(method)))
		g.gen.P(fmt.Sprintf("  %sSchema, err := json.Marshal(*jsonschema.Reflect(%s{}))", firstLetterToLower(method.Input.GoIdent.GoName), method.Input.GoIdent.GoName))
		g.gen.P("  if err != nil {")
		g.gen.P("    return err")
		g.gen.P("  }")
		g.gen.P(fmt.Sprintf("  %sSchema, err := json.Marshal(*jsonschema.Reflect(%s{}))", firstLetterToLower(method.Output.GoIdent.GoName), method.Output.GoIdent.GoName))
		g.gen.P("  if err != nil {")
		g.gen.P("    return err")
		g.gen.P("  }")
		g.gen.P("  if err := service.AddEndpoint(")
		g.gen.P(fmt.Sprintf("    %sSubject,", firstLetterToLower(method.GoName)))
		g.gen.P("    micro.ContextHandler(")
		g.gen.P("      ctx,")
		g.gen.P("      func(ctx context.Context, request micro.Request) {")
		g.gen.P("        select {")
		g.gen.P("        case <-ctx.Done():")
		g.gen.P("          code, description := s.errorMapper(ctx.Err())")
		g.gen.P("          request.Error(code, description, nil)")
		g.gen.P("          return")
		g.gen.P("        default:")
		g.gen.P(fmt.Sprintf("          req := new(%s)", method.Input.GoIdent.GoName))
		g.gen.P(fmt.Sprintf("          if err := s.encoder.Decode(%sSubject, request.Data(), req); err != nil {", firstLetterToLower(method.GoName)))
		g.gen.P("            code, description := s.errorMapper(err)")
		g.gen.P("            request.Error(code, description, nil)")
		g.gen.P("            return")
		g.gen.P("          }")
		if g.isValidatorEnabled {
			g.gen.P("          if s.isValidationEnabled {")
			g.gen.P("            if err := req.ValidateAll(); err != nil {")
			g.gen.P("              code, description := s.errorMapper(err)")
			g.gen.P("              request.Error(code, description, nil)")
			g.gen.P("              return")
			g.gen.P("            }")
			g.gen.P("          }")
		}
		g.gen.P(fmt.Sprintf("          res, err := s.%sServer.%s(ctx, req)", firstLetterToLower(service.GoName), method.GoName))
		g.gen.P("          if err != nil {")
		g.gen.P("            code, description := s.errorMapper(err)")
		g.gen.P("            request.Error(code, description, nil)")
		g.gen.P("            return")
		g.gen.P("          }")
		if g.isValidatorEnabled {
			g.gen.P("          if s.isValidationEnabled {")
			g.gen.P("            if err := res.ValidateAll(); err != nil {")
			g.gen.P("              code, description := s.errorMapper(err)")
			g.gen.P("              request.Error(code, description, nil)")
			g.gen.P("              return")
			g.gen.P("            }")
			g.gen.P("          }")
		}
		g.gen.P(fmt.Sprintf("          payload, err := s.encoder.Encode(%sSubject, res)", firstLetterToLower(method.GoName)))
		g.gen.P("          if err != nil {")
		g.gen.P("					   code, description := s.errorMapper(err)")
		g.gen.P("						 request.Error(code, description, nil)")
		g.gen.P("						 return")
		g.gen.P("					 }")
		g.gen.P("          request.Respond(payload)")
		g.gen.P("        }")
		g.gen.P("      },")
		g.gen.P("    ),")
		g.gen.P("    micro.WithEndpointSchema(&micro.Schema{")
		g.gen.P(fmt.Sprintf("      Request: string(%sSchema),", firstLetterToLower(method.Input.GoIdent.GoName)))
		g.gen.P(fmt.Sprintf("      Response: string(%sSchema),", firstLetterToLower(method.Output.GoIdent.GoName)))
		g.gen.P("    }),")
		g.gen.P("  ); err != nil {")
		g.gen.P("    return err")
		g.gen.P("  }")
	}
	g.gen.P("  return nil")
	g.gen.P("}")
	g.addEmptyLine()
	g.gen.P(fmt.Sprintf("func (s *%sServerRunnable) GetNatsMicroService() *micro.Service {", firstLetterToLower(service.GoName)))
	g.gen.P("  return s.service")
	g.gen.P("}")
}

func (g *generator) addServiceServerRunnableConstructor(service *protogen.Service) {
	g.gen.P(fmt.Sprintf("func New%s(", fmt.Sprintf("%sRunnable", service.GoName)))
	g.gen.P(fmt.Sprintf("  %sServer %sServer,", firstLetterToLower(service.GoName), service.GoName))
	g.gen.P("  options runnable.Options,")
	g.gen.P(") runnable.Runnable {")
	g.gen.P(fmt.Sprintf("  return &%sServerRunnable{", firstLetterToLower(service.GoName)))
	g.gen.P(fmt.Sprintf("    %sServer: %sServer,", firstLetterToLower(service.GoName), firstLetterToLower(service.GoName)))
	g.gen.P("    natsConnection: options.NatsConnection,")
	g.gen.P("    encoder: options.Encoder,")
	g.gen.P("    isValidationEnabled: options.IsValidationEnabled,")
	g.gen.P("    errorMapper: options.ErrorMapper,")
	g.gen.P("    errorHandler: options.ErrorHandler,")
	g.gen.P("    doneHandler: options.DoneHandler,")
	g.gen.P("    subjectPrefix: options.SubjectPrefix,")
	g.gen.P("    getSubject: options.GetSubject,")
	g.gen.P("  }")
	g.gen.P("}")
}

func firstLetterToLower(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)
	r[0] = unicode.ToLower(r[0])

	return string(r)
}
